現場で使える Ruby on Rails 5速習実践ガイド

<目次>
※Chapter.1(Ruby入門),2(実行環境構築)はskip

Chapter3 タスク管理アプリケーションを作ろう  
3-1 アプリケーション作成の準備をしよう   
3-1-1 作成するアプリケーションの内容を考える    
3-1-2 アプリケーションの名前を決める  
3-1-3 アプリケーションのひな形を作成する   
3-1-4 データベースの環境ごとの使い分け  
3-1-5 ビュー層を効率良く書くためにSlimを使えるようにする   
3-1-6 アプリケーションの見栄えを良くするためにBootstrapを導入する   
3-1-7 Railsのエラーメッセージなどを日本語で出せるようにする   
3-2 タスクモデルを作成する  
3-2-1 タスクモデルの属性を設計する  
3-2-2 タスクモデルのひな形を作成する  
3-2-3 マイグレーションでデータベースにテーブルを追加する   
3-3 コントローラとビュー  
3-3-1 新規登録機能を実装する  
3-3-2 一覧表示機能を実装する  
3-3-3 詳細表示機能を実装する  
3-3-4 編集機能を実装する  
3-3-5 削除機能を実装する  
3-3-6 シンプルなCRUD機能の完成  


＜レベルアップ編＞    
Chapter4 現実の複雑さに対応する    
4-1 さまざまなマイグレーション操作を使いこなす   
4-1-1 マイグレーションの適用を理解しよう  
4-1-2 マイグレーションではバージョンの上げ下げ両方を意識しよう   
4-1-3 マイグレーションの名前の付け方に注意する   
4-1-4 schema.rb   
4-1-5 マイグレーションに関する主なコマンド  
4-1-6 マイグレーションの適用中にエラーが出たときは  
4-2 データの内容を制限する 
4-2-1 データ型 
4-2-2 NOT NULL制約 
4-2-3 文字列カラムの長さを指定する  
4-2-4 ユニークインデックスを作成する  
4-3 モデルの「検証」を使う  
4-3-1 モデルの検証の仕組み   
4-3-2 検証の書き方  
4-3-3 必須かどうかの検証を追加する  
4-3-4 コントローラとビューで検証エラーに対応する  
4-3-5 文字列長の検証を追加する  
4-3-6 オリジナルの検証コードを書く   
4-3-7 検証が行われない登録・更新操作もある    
4-4 モデルの状態を自動的に制御する―「コールバック」    
4-4-1 コールバックの仕組み  
4-4-2 コールバックの実装  
4-4-3 トランザクション  
4-5 ログイン機能を作る   
4-5-1 セッションとCookie  
4-5-2 User モデルを作る   
4-5-3 パスワードを受け付けてdigestを保存する   
4-5-4 ユーザー管理機能一式を追加する  
4-5-5 ログイン機能を実装する  
4-5-6 ログインのフォームを表示する  
4-5-7 ログインの実行   
4-5-8 ログイン状態の取得を簡単にする   
4-5-9 ログアウト機能を実装する   
4-5-10 ログインしていなければタスク管理を利用できなくする   
4-5-11 ログインしているユーザーのデータだけを扱えるようにする   
4-5-12 管理機能を管理者ユーザーだけに利用させるようにする    
4-5-13 最初の管理者ユーザーを作る   
4-6 データを絞り込む  
4-6-1 絞り込みの起点   
4-6-2 絞り込み条件  
4-6-3 実行部分  
4-7 タスク一覧を作成日時の新しい順に表示する    
4-8 scopeを活用する  
4-9 フィルタを使い重複を避ける  
4-10 詳しい説明に含まれるURLをリンクとして表示する   
4-10-1 まとめ  

Chapter5 テストをはじめよう  
5-1 テストについて  
5-2 テストを書くことのメリット  
5-2-1 テスト全体にかかるコストの削減  
5-2-2 変更をフットワーク軽く行えるようになる   
5-2-3 環境のバージョンアップやリファクタリングの必須条件   
5-2-4 仕様変更の影響の大きさを簡単に把握することができる   
5-2-5 仕様を記述したドキュメントとしても機能する   
5-2-6 仕様やインターフェイスを深く考えるきっかけとして役立つ     
5-2-7 適切な粒度のコードになりやすい  
5-2-8 確実性を高めることで開発効率を上げる   
5-3 本章で利用するテスト用ライブラリ  
5-3-1 RSpec  
5-3-2 Capybara  
5-3-3 FactoryBot  
5-4 本章で記述するテストの種類  
5-4-1 モデルのテスト  
5-4-2 結合テスト  
5-4-3 ルーティング、メーラー、ジョブのテスト    
5-4-4 あまり利用しないテスト  
Column System Specとは？  
5-5 System Specを書くための準備  
5-5-1 RSpecのインストールと初期準備   
5-5-2 Capybaraの初期準備   
5-5-3 FactoryBotのインストール  
5-6 RSpecの基本形  
5-7 FactoryBotでテストデータを作成できるように準備する   
5-8 タスクの一覧表示機能のSystem Spec    
5-8-1 ユーザーAを作成しておく   
5-8-2 作成者がユーザーAであるタスクを作成しておく   
5-8-3 ユーザーAでログインする  
5-8-4 作成済みのタスクの名称が画面上に表示されていることを確認   
5-9 他のユーザーが作成したタスクが表示されないことの確認   
5-10 beforeを利用した共通化   
5-11 letを利用した共通化  
Column letとlet!  
5-12 詳細表示機能のSpecを追加する  
5-13 shared_examplesを利用する  
5-14 新規作成機能のSystem Spec  
5-15 letの上書き  
5-16 Specが失敗したときの調査方法  
5-16-1 Specが失敗するとき  
5-16-2 Specが失敗したときに確認すべき情報   
5-16-3 失敗場所とエラーメッセージを手がかりに原因を探す   
5-16-4 コンソールを使って調査する  
5-16-5 スクリーンショットを活用する  
  
Chapter6 Railsの全体像を理解する  
6-1 Railsを取り巻く世界
6-2 ルーティング
6-2-1 「 ルート」を構成する5つの要素
6-2-2 1つのルートを定義する
Column URLヘルパーメソッドは使わなくてはダメ？ 
6-2-3 「 RESTful」の概要をつかんでおこう 
6-2-4 RESTfulにするための Railsの流儀
Column RESTfulはどの程度追求すべき？ 
6-2-5 resourcesでCRUDのルート一式を定義する 
6-2-6 routes.rbの構造化
Column routes.rbの整理のコツ
6-3 国際化
6-3-1 ユーザーごとに言語を切り替える
6-3-2 翻訳ファイルの扱い方
6-4 日時の扱い方
6-4-1 日時の扱い方に関する設定
6-4-2 taskleafアプリケーションのデフォルトのタイムゾーンを日本時間にする 
6-4-3 Time.currentやDate.currentを利用する 
6-5 エラー処理のカスタマイズ
6-5-1 Railsのエラー処理の概要 
6-5-2 デバッグ用/本番用のエラー画面の切り分け 
6-5-3 Railsの本番用エラー画面のカスタマイズ  
6-5-4 アプリケーション固有のエラー処理の追加 
6-6 Railsのログ
6-6-1 ログの利用方法
6-6-2 ログ（ロガー）の設定
6-7 セキュリティを強化する
6-7-1 意図しないパラメータを弾く「Strong Parameters」 
6-7-2 CSRF対策を利用する
6-7-3 インジェクションに注意する
6-7-4 Content Security Policy（CSP）を設定する 
6-8 アセットパイプライン
6-8-1 環境による挙動の違い 
6-8-2 ブラウザにアセットを読み込ませる
6-8-3 連結結果のファイルをどうやって生成するか 
6-8-4 マニフェストファイルを記述する
6-8-5 アセットの探索パス
6-8-6 アセット関連の設定
6-9 production環境でアプリケーションを立ち上げる 
6-9-1 アセットのプリコンパイル
6-9-2 静的ファイルの配信サーバを設定する  
6-9-3 production環境用のデータベースを作成する 
6-9-4 config/master.key が存在することを確認する 
6-9-5 productionモードでサーバを起動する 
6-9-6 production環境用の秘密情報の管理 
6-9-7 秘密情報の暗号化・復号 
Column secret_key_base 
Column カスタム暗号化ファイル（Encrypted） 

Chapter7 機能を追加してみよう  
7-1 登録や編集の実行前に確認画面をはさむ 
7-1-1 確認画面を表示するアクションを追加する 
7-1-2 新規登録画面からの遷移先を変える
7-1-3 登録アクションで「戻る」ボタンからの遷移に対応する 
Column 確認画面があるほうが良いとは限らない 
7-2 一覧画面に検索機能を追加する
7-2-1 Ransackのインストール
7-2-2 名称による検索 
7-2-3 検索時のSQLの確認と検索マッチャー 
7-2-4 登録日時による検索
7-2-5 検索条件を絞る
7-3 一覧画面にソート機能を追加する 
7-4 メールを送る
7-4-1 メイラーの実装 
7-4-2 テンプレートの実装
7-4-3 メール送信処理
7-4-4 動作確認
7-4-5 メイラーのテスト
7-5 ファイルをアップロードしてモデルに添付する 
7-5-1 タスクに画像ファイルを添付する
7-5-2 Active Storage
7-5-3 Active Storageの準備
7-5-4 タスクモデルに画像を添付できるようにする 
7-6 CSV形式のファイルのインポート/エクスポート 
7-6-1 タスクをCSV出力（エクスポート）する  
7-6-2 CSVデータを入力（インポート）する
7-7 ページネーション 
7-7-1 kaminariのインストール
7-7-2 ページ番号に対応する範囲のデータを検索するようにする 
7-7-3 ビューにページネーションのための情報を表示する 
7-7-4 動作確認
7-7-5 デザインの調整 
7-7-6 表示件数を変更したいとき 
7-8 非同期処理や定期実行を行う（Jobスケジューリング） 
7-8-1 非同期処理ツールの導入
7-8-2 ジョブの作成、実行
7-8-3 実行日時指定
7-8-4 ７章の終わりに 

＜発展編＞  
Chapter8 RailsとJavaScript  
8-1 JavaScriptでページに変化をつける  
8-2 AjaxでRailsサーバと通信する
8-2-1 Ajaxでタスクを削除する
8-2-2 rails-ujsの果たしている役割 
8-2-3 コントローラからJavaScriptを返して実行する（SJR） 
Column CoffeeScriptは使わないことも検討する 
Column jQuery
8-3 Turbolinks
8-3-1 Turbolinksの発行するイベント
8-3-3 Turbolinksが有効な環境での注意点  
8-3-4 Turbolinksを無効化するには 
8-4 モダンなJavaScript管理を行う
8-4-1 Yarn 
8-4-2 Webpacker
8-5 taskleafにReactを導入してみる 
Column Webpackerのメリット・デメリット

Chapter9 複数人でRailsアプリケーションを開発する  
9-1 チーム開発の風景（導入編） 
9-1-1 ソースコードの変更を管理する
9-1-2 GitHubなどの開発プラットフォームを使う 
9-1-3 GitHubを使うには？
9-1-4 Pull Requestベースの開発
9-1-5 Gitに入れるファイル、入れないファイル 
Column database.ymlとセキュリティ
9-1-6 Pull Requestの変更差分を最新状態との比較にする 
9-1-7 Gitのpush -fに気をつける
9-1-8 GitHubとチャットツールを連携させる  
9-2 チーム開発の風景（コードレビュー編） 
9-2-1 コードレビューではどんな点を見て、何をコメントする？  
9-2-2 コーディング規約
Column コーディング規約との付き合い方
9-2-3 Lintツールの活用
Column コードレビューは素晴らしい、だが万能ではない  
9-2-4 CIツールとGitHubを連動させる
9-3 チーム開発の風景（分担編） 
9-3-1 チームで開発するときの分担の仕方
9-4 開発環境の構築方法をわかりやすくしておく 
9-4-1 誰でも簡単にセットアップできるようにする 
9-4-2 仮想化環境を利用する 
9-4-3 初期データ・テスト用データの共有
9-5 マイグレーションに注意する
9-5-1 ロールバックできることを確認しよう
9-5-2 「redo」を習慣にしよう
9-5-3 完全なロールバックができないとき
9-5-4 過去のマイグレーションファイルの変更には慎重になろう 
Column 「きれいなマイグレーション」を追求しない 
9-5-5 マイグレーションファイルが多くなってきたら 
9-5-6 直接DBを変更したら必ずマイグレーションファイルも追加しておこう 
9-5-7 データメンテナンス 
Column Rakeタスクでのデータメンテナンス

Chapter10 Railsアプリケーションと長く付き合うために  
10-1 バージョンアップにどう取り組むか
10-2 小さなバージョンアップ
10-2-1 bundle updateとは
10-2-2 bundle updateの際に行うべきこと
10-3 bundle update はチーム全体で行う 
10-4 bundle updateを自動化でサポートする 
10-5 大きなバージョンアップを行う際に気をつけること  
10-6 アプリケーションの複雑性に立ち向かう 
10-7 第一の鍵─しかるべきところにコードを書く 
10-7-1 コントローラに入り込む複雑さ
10-7-2 モデルに書くべきコードをモデルに寄せる 
10-7-3 ビューに入り込んだビジネスロジックをモデルに寄せる 
10-7-4 Decoratorパターンでモデル固有の表示ロジックを分離する 
10-8 第二の鍵─上手に共通化する
10-9 モデルの共通化
10-9-1 共通機能のモジュールを複数のモデルクラスにMix-inする 
10-9-2 STI（単一テーブル継承）で共通機能を基底クラスに持たせる 
10-9-3 全モデルクラスに共通の処理をApplicationRecordに書く 
10-9-3 ApplicationRecordとモデルクラスの間に抽象的なクラスを挟む 
10-10 コントローラの共通化
10-10-1 共通機能のモジュールを複数のコントローラクラスにMix-inする 
10-10-2 基底クラスを追加して共通機能を持たせる 
10-10-3 ApplicationControllerに共通機能を記述する 
10-10-4 第一の鍵を使わない状態で第二の鍵を使ってはいけない 
10-11 ビュー（プレゼンテーション）の共通化 
10-11-1 パーシャルテンプレートで画面の一部を共通化する 
10-11-2 レイアウトで画面の大枠を共通化する  
10-11-3 カスタムヘルパーに共通処理を記述する 
10-11-4 カスタムヘルパーは小さく作る 
10-11-5 特定のモデルに依存する処理をカスタムヘルパーに含めない 
10-12 第三の鍵─新しい構造を追加して役割を分担する 
10-12-1 ActiveModel
10-12-2 共通処理を担当するオブジェクトを別につくって連携させる 
10-12-3 意味のあるパラメータの集合からクラスを生み出す 
10-12-4 外部サービスのロジックを閉じ込める 
10-12-5 複数のモデルが絡む特定処理の専門家を作る 
10-12-6 サブリソース単位でコントローラを分割する 
Column 何でも屋のアクションを実装しない
10-13 モジュールを上手に利用するために
10-13-1 構造として分かりやすい意味を持たせる 
10-13-2 利用元クラスの一部として違和感がないかを検討する 
10-13-3 利用元クラスと内部データを共有していることを意識する 
10-13-4 独立的にして利用条件を分かりやすくする  
10-13-5 追加部品であるという節度を守る
10-14 おわりに
